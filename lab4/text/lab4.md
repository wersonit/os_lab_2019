# Лабораторная работа №4

## Задание 1

### Необходимые знания

1. Функция `kill`(Команда Kill посылает указанный сигнал указанному процессу)
2. Неблокирующий wait c `WNOHANG`(WNOHANG: означает немедленное возвращение управления, если ни один дочерний процесс не завершил выполнение.)
3. Функция `alarm` (предназначена для планирования генерации сигнала SIGALARM.), сигнал `SIGALRM`(применяемый в POSIX-системах сигнал по истечении времени, предварительно заданного функцией alarm() ), функция `signal`(позволяет процессу выбрать один из нескольких способов обработки сигнала прерывания от операционной системы).

Дополнить программу parallel\_min\_max.c из ***лабораторной работы №3***, так чтобы после заданного таймаута родительский процесс посылал дочерним сигнал SIGKILL. Таймаут должен быть задан, как именной необязательный параметр командной строки (`--timeout 10`). Если таймаут не задан, то выполнение программы не должно меняться.

### Ресурсы

1. [Системный вызов kill](http://man7.org/linux/man-pages/man2/kill.2.html)
2. [Системный вызов waitpid. Здесь информация о WNOHANG](https://linux.die.net/man/2/waitpid)
3. [Системный вызов signal](http://man7.org/linux/man-pages/man2/signal.2.html)
4. [Системный вызов alarm](http://man7.org/linux/man-pages/man2/alarm.2.html)

## Задание 2

### Необходимые знания

1. Что такое зомби процессы, как появляются, как исчезают.

Создать программу, с помощью которой можно продемонстрировать зомби процессы. Необходимо объяснить, как появляются зомби процессы, чем они опасны, и как можно от них избавиться.

### Ресурсы

1. [Немного теории по зомби процессам](https://www-cdf.fnal.gov/offline/UNIX_Concepts/concepts.zombies.txt)

## Задание 3

### Необходимые знания

1. Работа виртуальной памяти. (Принцип работы виртуальной памяти основан на понятии «страниц» и «страничного файла». Физическая память разбивается на небольшие блоки, называемые «страницами». Затем каждой программе присваивается свое адресное пространство, состоящее из набора страниц.)

Скомпилировать process_memory.c. Объяснить, за что отвечают переменные `etext`, `edata`, `end`.

### Ресурсы

1. [etext, edata, end](https://linux.die.net/man/3/edata)
2. [Неплохая статья (перевод), про то, как устроена память](https://habrahabr.ru/company/nixsolutions/blog/277759/)

## Задание 4

Создать makefile, который собирает программы из задания 1 и 3.

## Задание 5

### Необходимые знания

1. POSIX threads: как создавать, как дожидаться завершения.
2. Как линковаться на бибилотеку `pthread`

Доработать parallel_sum.c так, чтобы:

* Сумма массива высчитывалась параллельно.
* Массив генерировался с помощью функции `GenerateArray` из ***лабораторной работы №3***.
* Программа должна принимать входные аргументы: количество потоков, seed для генерирования массива, размер массива (`./psum --threads_num "num" --seed "num" --array_size "num"`). 
* Вместе с ответом программа должна выводить время подсчета суммы (генерация массива не должна попадать в замер времени).
* Вынести функцию, которая считает сумму в отдельную библиотеку.

### Ресурсы

1. [Туториал по POSIX threads от университета Карнеги-Меллона (в этой лабе вам нужно только начало)](https://www.cs.cmu.edu/afs/cs/academic/class/15492-f07/www/pthreads.html#SCHEDULING)
2. [Как можно мерить время (кстати в 3й лабораторной работе тоже есть пример)](https://www.gnu.org/software/libc/manual/html_node/Elapsed-Time.html)

## Задание 6

Создать makefile для parallel_sum.c.

## Перед тем, как сдавать

Залейте ваш код в ваш репозиторий на GitHub. Убедитесь, что вы не добавляете в репозиторий бинарные файлы (программы, утилиты, библиотеки и т.д.).




